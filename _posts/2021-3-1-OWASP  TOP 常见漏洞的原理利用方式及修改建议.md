---
layout:     post   				    # 使用的布局（不需要改）
title:      漏洞原理及应用 				# 标题 
subtitle:   体系结构    #副标题
date:       2021-3-2 				# 时间
author:     L 						# 作者
header-img: img/8.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - OWASP
---
# OWASP  TOP 常见漏洞的原理利用方式及修改建议



### 一、SQL注入	

#### SQL注入：SQL注入是👉web应用程序对用户的输入数据的合法性没有进行严格的审查，前端传入后端的参数是攻击者可控的，并且参数带入到数据库查询，攻击者可以通过构造不同的SQL语句来实现对数据库的任意操作

SQL注入条件：

​		1)参数用户可控：前端传入到后端的的参数内容是用户可控的

​		2）传入的参数拼接到SQL语句，且带入到数据库查询



**SQL注入漏洞常见利用：**

###### 			基础篇：1）union注入（联合查询，SQL注入的一种最基本的利用方式）

###### 							2）Boolean注入（注入查询时不直接返回查询信息，而是对查询的信息进行判断，在true和false时触发不同的回显）

###### 							3）报错注入（利用数据库的报错机制再借由某些函数进行数据库的信息泄露）

###### 			进阶篇：1）时间注入（注入时无法直接返回信息，借由时间函数在查询到正确信息时延时，根据程序执行时间判断注入所获取的信息）

```
说明：数据库交互完成后目标站点没有正确或错误的页面回显，这种情况就可以利用时间函数构造语句进行判断
```



###### 							2）堆叠查询注入（堆叠查询可以执行多条语句，多语句之间用“；”隔开，即多个查询语句嵌套进行查询）

```
说明：某些特殊的字符或者数据库信息关键字被过滤或屏蔽时，利用嵌套语句查询的结果来作为外层查询语句的参数
```



###### 							3）二次注入（顾名思义二次注入则是一次注入两个步骤，第一步构造非法查询语句插入数据库，第二步引用恶意数据触发SQL注入）

```
这里说一下，为什么要分为两步：

​		第一步插入恶意数据时web应用对输入的数据进行检查、转义，导致了构造的非法语句不能直接起作用，但是被处理的数据插入到数据库时又被还原成原始数据存储到数据库中，

​		第二步，开发者默认已经存入数据库的数据都是安全的，当web应用程序调用存储在数据库的恶意数据并执行SQL查询时，没有进行进一步的检测就直接取出恶意数据，这就导致了二次注入。
```



###### 							4）宽字节注入（该注入方法涉及到一种数据库的字符编码“GBK编码”，当数据库使用转义符“\”转义的时候）

```
宽字节的格式是在地址后加一个  %df  再加单引号，而因为反斜杠的编码为  %5c，恰恰在GBK编码中两个编码组合起来的 %df%c是繁体字“連”，导致了转义符失效，造成了单引号逃逸，引发了数据库安全问题
```



###### 							5）cookie注入（在访问web应用程序中，如果没有完整严格的审查，以post提交的表单中的cookie参数引发的注入漏洞）

###### 							6)XFF注入（XFF--X-Forwarded-For，XFF头代表着客户端的真实IP（也没那么真，也是🉑伪造的），如果没有检查也是会存在注入漏洞的）

MySQL注入知识点：

在MySQL5.0版本以后，MySQL默认在数据库存放一个“information_schema”数据库，该数据库有三个主要的表名分别为SCHEMATA、TABLES、COLUMNS

SCHEMATA表记录了用户创建的所有数据库库名，该表中记录数据库库名的字段为SCHEMA_NAME。

TABLES表存储着该用户创建的所有数据库库名以及表名，数据库库名字段为“TABLE_SCHEMA”，表名字段为“TABLE_NAME”

COLUMNS表该用户创建的所有数据库名，表名和字段名，他们的字段分别为SCHEMA、TABLE_NAME、COLUMN_NAME

SQL注入绕过：

简单的绕过可以大小写、双写以及全编码绕过，内联注释绕过---/ *and */(由于限制前面内联注释/与*间有空格，实际运用时没有)，针对于每个过滤的点也有不一样的绕过方法

### SQL注入修复建议

​	对用户的输入的数据进行严格的审查与过滤，特别是过滤一些危险字符（‘ 、 “ 、  --+、#、/、\、//、and 、 union、等等）

​	使用预编译语句

​		SQL之所以能被注入，最主要的原因就是它的数据和代码（指令）是混合的。C程序为什么从来没听说过注入这种说法，有的也是溢出。这是因为C是一种编译型语言，你没法在语义上欺骗它，语义解析这步提前做了，都生成二进制了。所以攻击C的方式大多是溢出，通过溢出让数据覆盖指令段。数据库也提供了这种分离数据和代码（指令）的方式，就是SQL预编译。而SQL语句在程序运行前已经进行了预编译，在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库已参数化的形式进行查询，当运行时动态地把参数传给PreprareStatement时，***\*即使参数里有敏感字符如 or ‘1=1’也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令\**。**

使用PDO预编译语句要注意，不要直接将变量拼接到PDO语句中，而是使用占位符进行数据库的增、删、查、改

### 二、XSS跨站脚本攻击

​		XSS是一种针对网站应用程序的攻击，是代码注入的一种。恶意用户将恶意代码注入到网页形成XSS攻击，利用XSS可以非法访问某些页面内容以及盗取会话和cookie等

XSS可分为三种：反射性、存储型、DOM型

1、反射型XSS：其也称为非持久型XSS，这种攻击具有一次性。攻击多为攻击者通过各种方式将带有XSS的恶意链接直接发送给目标，当目标点击该链接时触发目标用户的浏览器解析该XSS恶意脚本后发生的攻击

2、存储型：该种也称为持久性XSS，攻击脚本多被永久的存放在目标服务器的数据库中或文件中，具有较高的隐蔽性

这种攻击多出现在论坛、博客、留言板等，攻击者在发布内容的时候把恶意脚本与正常内容一起输入到文本中，随着文本被服务器保存下来，恶意脚本也被保留在服务器中，每当其他用户访问该内容时XSS脚本都会被触发。存储型XSS能够将恶意代码永久的嵌入一个页面中，所有访问该页面的用户都会触发攻击。

3、DOM型XSS：DOM全称为Document Model，使用DOM可以使程序和脚本能够动态访问和更新文档的内容、样式等

DOM型XSS其实是一种特殊的反射型XSS，它是基于DOM文档对象类型的一种XSS代码注入漏洞

HTML DOM树

![IMG_20210301_131559](//tva3.sinaimg.cn/large/006O5vizly1go4c204lg5j33011rlx6p.jpg)

攻击方式：用户请求一个经过攻击者设计的URL，其中包含恶意XSS代码，服务器的响应不会以任何形式包含攻击者的脚本。当用户浏览器处理这个响应时，DOM对象会处理XSS代码，导致XSS攻击

XSS修复建议：XSS漏洞涉及到输入输出两部分，修复亦然

·过滤输入数据，包括单引号，双引号，”<“  ">"  "on*"等非法字符

·对输出到页面的数据进行相应的编码转换，包括HTML实体编码，JavaScript编码等

### 三、CSRF漏洞

CSRF：跨站请求伪造，也被称为one click attack/XSRF，是一种对网站的恶意利用。表面上CSRF与XSS看起来非常相似，但是两者之间还是有很大的区别的，XSS利用网站内受信任的用户去进行恶意攻击，而CSRF则是伪造成受信任用户去请求受信任网站进行攻击。即CSRF---攻击者利用目标用户的身份以受害者的名义执行一些恶意操作而XSS是真实的目标用户点击触发的

CSRF修复建议：

·验证请求的referer值

·在HTTP请求中加入一个随机产生的token，并在服务器对该token进行验证

### 四、SSRF漏洞

SSRF：服务器端请求伪造，是一种由攻击者构造请求由服务端发起的安全漏洞。一般情况下SSRF攻击的目标是外网无法访问的内部系统（与该服务器相连的内部系统）

SSRF漏洞原理：SSRF形成多是服务端提供了从其他服务器获取数据的功能且没有对目标地址进行限制和过滤，SSRF利用存在缺陷的web应用作为代理攻击远程或本地的服务器。

主要攻击方式

​	· 对外网、服务器所在内网、本地进行端口扫描获取服务器banner信息

​	· 攻击运行在内网或本地的应用程序

​	· 对内网web应用进行指纹识别，探明企业内部资产信息

​	· 攻击内外网web应用，主要是使用HTTP GET请求可实现的攻击（SQL、struts2）

​	· 利用file协议读取本地文件

SSRF漏洞修复建议：

​	·	限制不能访问内网的IP，以防针对内网的攻击

​	·	屏蔽服务器返回的详细信息

​	·	限制请求端口只能为web口





